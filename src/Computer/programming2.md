# 编程

> 代码是工人，开发者就是工头，指挥源代码工作。而这，正是数字经济的核心。 ————《未来地图》

> 要么是用户控制程序，要么是程序控制用户。
> -- 理查德・斯托曼

> 像奴隶一样工作，像国王一样命令，像神一样创造。
> -- 康斯坦丁·布朗库西，1876 年－1957 年，现代主义雕塑先驱

> 最好的工程师不是写代码最多的工程师，而是做出未来可以少写代码的决策的工程师。
> -- Dan Goldin

> 最好的程序员不是善于编写复杂代码，而是有能力为复杂的问题提出简单的解决方案。只有糟糕的程序员，才会对简单的问题提出复杂的解决方案。

> "减少人类的苦难"，对我来说就是软件价值的核心。我过去和现在所做的工作都以此为目标。

> 程序员对渐进式翻新不感兴趣：修修补补、改进、在花坛种上绿植...... 他们不想做这些事，他们总是想扔掉旧代码并重新开始，原因并非是认为旧代码一团糟，而是编程的一个基本法则：阅读代码比编写代码更难。

程序员的竞争力并不是写代码，也并不是哪门语言或者框架， 其核心竞争力是通过技术解决问题的能力。

先思考再编程，想好了再动手，避免写到后面发现需要推倒重来。

不要在疲惫时写代码，真正好的代码是程序员完全进入状态的时候写出来的。

有一个诀窍，让我成为一个更好的程序员，那就是我常常休息，大量的休息，我的新想法都是在休息时产生的。

休息的时候，我阅读，大量阅读任何我有兴趣的内容，这样我才可能产生新想法。

每当你有一种 "应该有人在这里做某事" 的感觉，那个应该做这件事的人很可能就是你。

> “If you can’t explain something in simple terms, you don’t understand it.”  如果你不能用简单的语言来解释某件事，你就无法理解它 — Richard Feynman

> “Just when you think you’ve successfully navigated one obstacle, another emerges. But that’s what keeps life interesting.
> 就在你认为已经成功跨域了一个障碍时候，另一个障碍有出现了，但这正是让生活变得有趣的地方。

> Each time, a little more of the competition falls away. Until all that is left is you: the best version of you.” — Ryan Holiday
> 每次，更多的竞争就会消失。直到你成为最好的自己。——瑞安. 霍利迪（障碍就是路）

“像程序员一样思考”, 是一种更有效的解决问题的方法。找到正确的框架，练习它。

编程是思考，而不是打字。多年编程后，我时常觉得自己打字太多，思考太少。

一种更强大的编程哲学，你应该忽略代码，那只是计算机要遵循的一大堆指令。相反地，你要专注于数据，弄清楚它如何流动。

计算机科学中的一切都循序渐进的. 知识点是循序渐进的，略过前面的知识点无异于搭建空中楼阁.

如果当前你正在学习的知识点对你而言很无厘头, 请停留在当前位置, 暂不要进行下一个知识点。
如果您使用的辅导资料(或书籍)没有充分诠释该知识点, 那么务必去寻找其他适合您的资源。
请避免过多负面的自省，不要被各种问题打击到怀疑人生, 坚持下去。

我见过的最好的工程师，是那些愿意在周末花几个小时构建一个现有软件的自己版本的人。
这就是你获得创新和进步的方式。如果你不了解系统的工作原理，就无法找到改进的地方。

一个优秀程序员，最开始是实施者（implementer），然后进化到解决者（solver），最后变成发现者（finder）。

[程序员的誓言](https://blog.cleancoder.com/uncle-bob/2015/11/18/TheProgrammersOath.html)

为了捍卫和维护计算机程序员的职业荣誉，我承诺，尽我所能和判断力：

1、我不会产生有害的代码。

2、我制作的代码永远是我最好的作品。我不会故意允许在行为或结构上有缺陷的代码。

3、每次发布时，我都会生成一个快速、可靠、可重复的证据，证明代码的每个元素都应该正常工作。

4、我将经常发布小版本，这样我就不会妨碍其他人的进展。

5、我会抓住每一个机会，无畏地，不懈地改进我的代码。我永远不会损害它们。

6、我将尽我所能保持自己和他人的生产力。我不会做任何降低生产力的事情。

7、我将继续确保支持其他人的工作，并且他们也可以支持我的工作。

8、我将对幅度和精度做出诚实的估计。我不会作出做不到的诺言。

9、我将永远不会停止学习和改进我的手艺。

优秀的程序员会在项目开始前，主动帮助产品把需求明确细化，这样可以避免开发阶段的无效的加班和工作。

提交代码后，谷歌内部有两次代码审查。第一次审查是功能审查，确保代码按照预期工作；第二次审查是可读性审查，确保代码是可读的，并且易于理解和维护。

SPOT（Single Point Of Truth，单点事实）。代码需要修改时，你只需要在一个地方修改，而不必改动多个地方。

复用的本质是通过消除重复的方式。得到一系列可以复用的组件，从而在未来的开发工作中，更快速的响应需求变化。但如果为了复用，代码的可读性下降了，更难维护了，也就违背了复用的本质。

函数是最重要的实现代码复用的手段。

## 标准库

数据结构
文本处理
时间日期
进程线程（环境变量、命令参数）
终端界面
图形界面
文件目录
网络连接

### 分而治之 (Divide and conquer)

理解、计划、拆分、探索、实践。

### 命名

每一个变量、函数、文件名 – 就如同给你的孩子取名字一样认真去给他们取名字。也许你今天通过把它命名为 x 节省了 0.3 秒的时间，但是在接下来的一个月你将会花 2 天的时间来搞清楚 x 到底指代什么，然后再花 4 天做重构。好好想想，不要担心命名太长。

### Closure

当一个函数能够记住并访问到其所在的词法作用域及作用域链，并能够在其定义的作用域外进行访问，此时该函数和其上层执行上下文共同构成闭包。

### Design

API 设计——库所提供的公共接口，向开发人员暴漏功能和特性——与 UI 设计一样重要。

应用程序的 UI 关注的是终端用户的体验，应用程序的 API 关注的则是开发人员的体验。就像我们重视 UI 的实用、简洁和优雅，我们也应该追求 API 的实用、简洁和优雅。

差劲的设计会导致浪费：浪费开发人员的时间，因为他们很难弄懂一个接口；浪费 API 作者的时间，因为她需要处理开发混乱带来的额外支持和返工。

良好的 API 设计可以实现抽象这一目标，同时也应该是自描述的。如果一个 API 被良好地设计，用户可以快速直观地利用你的工作成果，而且不需要经常参考手册和文档，不需要频繁访问技术支持和问答网站。对于需要开发人员花费大量时间来开发的特性，你也可以把它们封装起来以节省开发人员的时间。良好的设计不仅可以节省开发人员的时间，也让他们看起来更加聪明和可靠。

我们可以把艺术领域中常用的的 4 项设计原则应用到 API 设计中：

- 一致 & 协调
- 平衡
- 相衬
- 重点突出

一致性是一件作品背后不可或缺的概念，使得设计者可以把各种事物汇集成一个连贯的整体。另一方面，协调性则是指作品中相似元素的布局，使得作品从整体上产生一种简洁的感觉。一致性和协调性的目的在于向 API 新手传达友好和舒适的感觉。虽然 API 的功能不同，但是通过相同或相似的 “方言”，可以大大降低开发人员采用新工具的门槛。

第二个原则是平衡，布置元素时要不能让作品的某个部分过于出彩而是其他部分黯然失色，或者让人感觉作品不稳定。在艺术上，平衡与视觉权重（吸引力）有关。在 API 设计中，平衡特指代码的视觉权重和可预测性。

第三个原则是相衬，它用来衡量作品中元素的大小和数量。并不是说小 API 就是好 API，相衬性所衡量的大小与 API 的用途（功能）有关。一个具备相衬性的 API，它的外观应该与它的能力范围相匹配。

在艺术上，突出重点是指通过使用对比，使作品的某个方面凸显出来成为焦点。在许多 API 中，焦点可能是锚定库的入口方法或主方法。突出重点的另一个示例可能是 “链式” 或流式 API，它可以突出库所使用的中心对象。

### 十步学习法

第一步：了解全局

第二步：确定范围

第三步：定义目标

第四步：寻找资源

第五步：创建学习计划

第六步：筛选资源

第七步：开始学习，浅尝辄止

第八步：动手操作，边玩边学

第九步：全面学习，学以致用

第十步：乐为人师，融会贯通

### 任务分解方法：

1. 定义问题
2. 把大问题分解成小问题
3. 为每一个单独问题设计算法
4. 把解决方案组合成系统

## 元编程：用程序来生成程序

That's the beauty of new things: there's always a new one coming along. Don't let the pursuit of new, shiny things accidentally become your goal. Avoid becoming a magpie developer. Be selective in your pursuit of the shiny and new, and you may find yourself a better developer for it.

### Tidying Up Your Code: KonMari Style

The six basic rules of tidying.

RULE 01 定下整理的决心
Commit yourself to tidying up.

RULE 02 想象自己的理想生活方式
Imagine your ideal lifestyle.

RULE 03 舍弃是整理的第一步
Finish discarding first.

RULE 04 按类别整理而不是按照地点
Tidy by category, not by location.

RULE 05 按照正确的顺序
Follow the right order.

RULE 06 这件物品让你怦然心动吗？
Ask yourself if it sparks joy.

Konmari 法则中最重要的一点就是：只留下让你怦然心动的物品。

## 逻辑编程（logic programming）

在像 Prolog 这样的逻辑式语言里面，“未知数” 是可以被作为一个正常的值来进行计算的。它们可以被传递到其它函数里，可以被放进数据结构，可以进行复杂的逻辑组合操作。

逻辑式程序中一般会有一个（或者多个）“目标”（goal）。目标一般是一个判断表达式，也就是说它的值是布尔类型（boolean）。逻辑语言的运行系统进行 “反向计算”，找到未知数的值，使得目标的值为 “真”（true）。

机器学习的 weight 对应于逻辑编程的 “未知数”（比如 X），机器学习中的误差函数（loss function）对应于逻辑编程的 “目标”（goal）。只不过逻辑编程的 goal 是个等式，而机器学习的 loss function 是个函数。机器学习的 weight 本质就是 “未知数”，给它们一些随机的初始值，让系统开始正向计算，直至遇到 loss function，然后掉头回去调整未知数的值。

逻辑编程系统会为你选择未知数的值，从而精确地 “满足” 这个 goal。而机器学习的目标呢，是要为你选择未知数的值，最小化这个 loss function，使得误差最小。所以，机器学习可以被看成是 “在连续空间中的近似的逻辑编程”，而逻辑编程可以被看成是 “在离散空间中的精确的机器学习”。

逻辑编程有 “反向计算”，机器学习有 “反向传递”(back propagation)，而它们的工作方式，有着惊人的相似之处。只不过机器学习因为是连续空间的，所以需要使用微积分的原理，而不只是简单的逻辑组合。

实际上逻辑编程必须先进行正向计算，构造出含有未知数的结构，然后进行所谓 “unification”，求出未知数的值。而机器学习也类似，你必须进行一遍正向计算（forward pass），然后才能进行 back propagation，求出导数，并且更新 “weight” 的值。由于机器学习解决的是连续的数值问题，机器学习的 “模型” 一般要很简单才行，否则很可能出现学习不收敛的情况。

机器学习的各种框架（framework）可以看成是新的编程语言，它们不同于 Python 或者 C 一类的过程式语言，而更像 Prolog 这样的逻辑式语言。这些语言会自动对代码求导，优化未知参数，使得误差最小。动态语言和静态语言的差别，对应着 Pytorch 和 TensorFlow 的动态计算图和静态计算图的区别。

目前机器学习的一些发展趋势：

1. Feed-forward 网络，比如 CNN 一类的，对应了编程语言中最简单的表达式，或者叫 “纯函数”。其中没有递归，也没有副作用。它只能处理图像一类具有固定长度的数据。
2. RNN（LSTM）对应的是程序语言里含有单个递归（循环）的函数。由于递归函数对应的是 “递归数据结构”，这就是为什么 RNN 可以处理文本这类线性 “链表” 数据。
3. Neural Turing Machine 及其后续的研究 Differentiable Neural Computer，试图把更广阔的编程概念引入到机器学习里面，处理任意复杂的数据结构，比如图结构。

库和框架的一个区别是，一次可以使用多个库，但是框架一次只能使用一个。

这就是为什么我不使用框架的原因。一旦用了一个框架，就无法再用另一个框架了，移植的成本太高了。使用库就没有这个问题。

团队每次使用框架时，都会冒风险。风险在于，框架可能在你的软件之前"消失"，从而给开发人员带来沉重的负担。

# A/B 测试

当没有足够多的信息，在我们不确定什么决策是正确的时候，通常会依赖于直觉做决定。但是直觉并不总是对的，最好的决策需要把直觉、经验和事实综合起来考虑，通过 A/B 测试的流程来知道我们的直觉是否是对的。

A/B 测试是在保持其他变量相同的情况下，比较一两个关键变量引发的结果。A/B 测试过去主要用在市场营销和广告中，现在也是一些精益创业公司快速寻找价值增长的方法。

## A/B 测试的 4 个步骤

1. 获得稳定的数据流：自动采集数据并且提供易用的数据分析工具。
2. 找到对比组：各组拥有近乎相同的特征。
3. 设定测试目标：改变什么变量，然后测量什么指标。
4. 同时进行两种不同的选择，实时地观察相应的结果。

## 软件开发

让自己成为自己开发的产品的第一批用户的实践, 我们称为 dogfooding.

### 需求确认

需求确认的方法：分析、仿真、演示，目的是对需求规格说明中描述的需求的正确性、一致性、完整性、可行性、必要性、可测试性进行确认。

- 分析

通过对需求规格说明的分析来确认软件需求的方式，通常就是审查或评审。虽然全凭想像，但是有客户和开发人员一起分析，应该可以实现确认的目的。

- 仿真

通过使用一种低保真的模型模拟软件的方式来确认需求。由于有了可感知的东西，需求的确认更加可信。

- 演示

当具备了初步的软件原型的时候，就可以通过软件原型的演示对需求进行确认。这这种需求确认的方式可信度最高，因为他和将来软件的使用场景非常接近。

需求确认的内容一般包括以下特征/内容：

1. 正确性

需求描述必须是正确的。否则，实现的软件就是错误的。而需求的正确性只能由客户来确定。但是客户的思维方式和开发人员完全不同，所以，要让客户做好需求正确性的确认，应当尽可能地使用客户的语言描述或解释需求，最好让客户感知到软件的使用场景。

2. 一致性

需求描述的一致性有几个层次。首先是需求规格说明上下文的一致性。比如，对同一术语，上下文要保持一致。其次是与其他软件需求或高层需求一致性。比如，与用户需求的一致性；与非功能需求的一致性。

3. 完整性

完整性也有两个方面的含义。一是需求描述元素的完整性，包括状态，状态变化，转入，产品和约束等。二是需求与客户的期望相比是否有遗漏。这个层次的完整性在确认客户需求的时候就应由客户来做确认，在对需求规格说明进行确认时，也可以再次确认需求的完整性。

4. 可行性

需求必须是可实现的。要综合考虑技术水平、资源保障等多方面的因素。

5. 必要性

客户提出的需求不一定都是必要的。软件开发人员应当从软件帮助客户解决的问题的终极目标出发，考虑技术和环境的限制，分析软件的需求，确定哪些需求是必要的，哪些需求是冗余的。

6. 可测试性

软件的需求一定是可测试的，否则就无法进行验证和确认。需求的可测试性要求需求应当尽量采用量化的描述方式。

## 公司为什么需要建立一套统一的开发框架

1. 避免重复性技术研究——节约人力成本
   让项目组把精力更多的投入到业务中。在项目组之下构建一个基础的开发架构平台，把技术的共性问题提炼出来，交给这样一个团队负责处理。避免每个项目都独自去解决遇到的各种各样的技术难题，有效的把精力释放出来。

2. 标准化技术规范——提升产品项目质量
   采用统一的开发框架（平台）后，在技术栈，技术组件，技术实现方案，甚至在代码规范上就能形成标准化的技术输出模式，标准化带来的最大效果不仅仅开发效率的快速提升，还有产品质量的大幅提升。

3. 进行技术沉淀——提升公司整体技术能力，避免陷入一个人的能力决定一个项目
   技术的进步来源于不断的技术积累和沉淀。每个工程师都是站在别人肩膀上完成工作的。以项目为导向的技术团队，一般都会以实现业务需求为最重要的目标，技术只不过是完成业务的一种工具而已。基于此，业务开发团队就不可能把技术积累作为一项重要的工作。  
   当存在核心同事离职时，平台的研发同事可以对新进入项目的同事进行相关培训，不会导致青黄不接的事情发生。而且，专注于平台的同事为了更好的满足项目组的技术需求，对平台进行不断的改进，从而达到技术积累和沉淀的目标。

4. 可衡量的研发投入——对研发团队的有效管理和考核
   当基于同一开发框架的标准化技术规范建立起来后，对业务功能的代码实现就可以进行相对有效的评估和考量，可以避免因为技术实现差异而出现的种种问题。这对 KPI 的制定和考核是一个巨大的帮助。

### 需求分析

拿到产品需求就开始吭哧吭哧的做方案设计，这是新人通常容易犯的错。有时候产品经理所做的需求方案设计并没有考虑充分。 我接触到的有些产品是直接拿着竞品的特性对着抄的，而且大多数时候是只考虑了正常情况，异常情况并没有考虑进去。又或者本身就不太适合做到现有系统里。导致做完实现后产品可能又说这个需求不做了。网上有很多段子说程序员与产品的有些矛盾就是这么来的。但本身这个事情开发这边也有错。拿到需求后，我们可以遵循如下方法先走一轮：

what【这个需求是什么，在什么场景下使用，谁来用】
why 【为什么要做这个需求？能给用户带来什么价值?】
how 【怎么做，是否可以不做，是否可以换其他方式来达到同样的目的？异常情况有哪些，针对异常情况如何处理？有哪些潜在的体验问题或者性能问题？】
when 【这个需求完成时间结点是什么时候？跟哪个版本？什么时候转测？是否是重点特性？】
跟产品经理谈 what 和 why 以及 how。可以帮助他理清楚需求的细节，把异常情况都考虑进去。 在这个阶段可以把不靠谱的需求 pk 掉或者修改掉。但是这种方式不太适用于老板的需求。如果对方以这是 boss 的需求为由，除非很不靠谱，要不就只能埋头做了。 谈 when 可以帮助你理清楚需求的优先级和重要程度，进而重新调整自己工作任务的优先级。

### 方案设计

- 借助图示剖析系统。人脑能够记住的东西有限，拿到系统之后。把脉络梳理出来。可以借助 processon 在线作图工具，把系统的状态流转图，以及 流程图 画出来。在这些流程过程中需要传递什么数据，需要缓存和持久化什么数据自然就出来了。然后再设计内存数据模型以及持久化数据模型。

- 方案设计先走常规流程，再覆盖异常情况。
  跟人讲设计方案的时候，只讲正常处理流程。这样子方便讲清楚梗概。 然后再讲异常情况，边界情况处理。 作为方案的后续补充。
- 做方案设计永远要准备 B 方案。陈述利弊，调研清楚类似产品的方案实现有缺点。要有推导过程。 没有推导过程的方案难以服众。

- 编程要提炼抽象和重构能力。
  抽象是使得接口简洁，隐藏实现细节，构造可维护可复用代码的一个好的方式。适时的抽象可以减少很多重复无用的工作。

### 统一开发框架的定位和目标

统一开发框架定位于技术层面，其主要目的是为统一公司内相关产品研发和项目实施使用的技术架构和开发工具，有效提高统一技术支持力度，形成持续的技术积累手段，提升技术人员的利用率并降低对人员的依赖性，最终提升软件的规模化、流水线式的生产能力。

### 代码审查

[8 Tips for Great Code Reviews](https://kellysutton.com/2018/10/08/8-tips-for-great-code-reviews.html)

### 敏捷三角：价值，质量和约束。

![](https://insights.thoughtworks.cn/wp-content/uploads/2019/03/AgileTriangle-SWDebt1.png)

传统的项目管理铁三角(范围、时间、和成本)被局部化成一个维度，称为约束。而引入了新的维度，价值和质量。其中价值代表的是利润等正向的因素，而质量代表的是变化的成本。质量越好，意味着变化的成本越低。据此，我们打破铁三角的第一个手段是，关注真正的用户价值，降低变化成本，并为此而调整计划。

持续学习，提升每个个体的效率。我们通常说程序员之间的效率差异会达到数量级的差别。通过自动化减少手工工作，通过预防错误避免返工，改进 DevOps 流程等。

## 测试

大型项目很难通过肉眼检查验证正确性。代码太多，你的大脑很难一次记住。

当测试失败时，仅从测试失败的信息中找到原因也是一个挑战。

从心理学角度来看，在面对一个长年累月的项目时，设置简短的中间态里程碑是很重要的。不断的完成这些里程碑让我干劲十足。

一直让代码保持可编译、可运行和可通过测试的状态也很好。当最终要面对那些日积月累的缺陷时，你将很难下手解决。

## 技术选型

写代码容易，写好很难，每一个部分给出合理设计与实现，并考虑扩展性、易维护、高性能可以说是相当高要求的一件事。

软件设计与实现是需要我们持续投入热情、投入精力的一件事。

对未来以及技术演进方向的把握，可以说是一件非常困难的事情。

每年都会有层出不穷的新技术产生，也会有一些技术走下坡路甚至走向消亡。对于技术发展路径前景需要对当下有深刻认知，以及对未来演进理解才能有一定程度上正确认知，有正确的认知是投资那种技术前提，花费多少时间去学习，能给研发效率带来提升，带来效果提升，以及团队技术水平的提升。新技术能带来一个公司甚至行业巨大发展，判断准确是在技术浪潮之中取得成绩的前提。

新出现的技术如果判断失误，一个小的团队来说就是花费错误的时间与精力去研究没有什么实际价值的技术，花费大量时间成本，对于一个公司判断错误可能就是生死。

减少研发重复性工作投入提升研发效率。以及提升我们实现业务逻辑抽象能力，以及技术研发水平，由研发业务慢慢转移到研发框架。

## 项目规模

一个亿级用户的项目比一个千万级用户的项目的复杂度，不是只高一倍的，项目的复杂度是成指数增长的。你在一个千万级用户项目中遇到的一个小问题，在亿级用户的项目中，却有可能是最难解决的问题。

除了功能需求，还需要考虑安全需求，性能需求，可靠性，稳定性等。这些才是系统设计的难点和关键点。架构师要从产品需求，业务需求里面提出安全，性能，可靠性，稳定性等系统层面的需求。

一个故障发生后，肯定是先处理，然后安抚用户，待一切处理完毕，我们通常会由系统的负责人，出一份故障报告。这份故障报告会详细的记录故障的处理过程，比如 xxx 时 xx 分，xxx 做了什么操作，然后还会详细描述故障产生的原因和后续的改进措施。

这份故障报告写完后，会以邮件的形式发给整个团队，大家会一起来 review 故障的处理过程和故障产生的原因。

我们会定期举行故障复盘会议，大家会在一起讨论问题的根本原因和改进的措施，更进一步的，会由点及面的延展开来，全局看待问题。

有意识地去分享和打造自身的影响力是特别重要的。对外分享，可以是写篇文章，可以是写个 ppt，给组里，给整个项目团队，或者给一些外部会议做分享，都可以慢慢地积累起这种影响力。

### 基本功

什么是基本功？不是那些高大上、新潮的技术、框架，而是程序员每天做的基础工作。比如，快捷键是否熟悉，测试习惯好不好，代码干不干净，打字速度有多快等等。程序员的基本功才是真正影响开发效率，甚至影响整个项目成败的核心。

能做和能做好是两回事。在我看来能做就是程序员懂得这个招式是干什么的，知道做什么，需要用什么招式。而能做好则指的是能够熟练使用招式，运用自如的同时可以举一反三。而能做和能做好之间差的就是基本功。

程序员 80% 的工作，尤其软件开发方面，都是在用基本功，而不是内功。

因为软件开发这个工作，确实大部分的时间，都是在搬运代码和改 bug ，而这些工作恰巧都是需要基本功的。

比如快捷键用得好，就是能够节省时间，提高效率；

比如养成单元测试的习惯，就会减少很多 bug 的出现，既节省了测试的时间，又能节省你改 bug 的时间，单元测试的时间，可能都不及你改 bug 时间的十分之一；

比如养成良好的编码习惯，可以大大提高你代码的阅读效率，在产品更新迭代的过程中，你可以非常快速的完成代码的修改；

比如你打字速度很高，绝对提高了你代码编写的速度；

虽然基本功都是非常常识性的，非常简单的东西，但是就是这些往往看似简单的东西，大家都不重视。这就是典型的还没学会走，就想跑的思想。其实在这个浮躁的社会中，这样的现象太多了，就像练习武术一样，很多武侠人士之所以走火入魔就是不重视练习基本功，感觉这个太简单了，我不想练习，我想直接练大招，学习降龙十八掌。

这样的现象确实很普遍，我所认识的大部分程序员，真的自己写完代码，别说单元测试了，其实自己连简单测试都懒得做。我所经历的公司大部分公司都是不写单元测试的；编码习惯更是各种各样。

所有的事情都是一样的道理：越是简单的东西，大家往往越不重视，而往往越是这些基础的东西才是真正决定能否成功的关键。

基本功就得这样练才行，习惯养成之后，基本功就扎实了，扎实之后，你想不用都难，大脑和肌肉自然而然的就会使出这些基本功。

经验总结

- 系统地学习原理性的知识
  数据结构与算法，计算机组成结构，编译原理
- 痴迷于寻找和学习最好的编程语言
  C#,Python,Euphoria,Haskell,Lua,Ruby,Rust
- 大量的实践和练习
- 追求高效和高质量的代码
- 关注最新的技术进展
